#version 460 core

#define NO_UNROLL 0


//random.glsl declarations
vec4 rand4();
vec3 rand3();
vec2 rand2();
float rand();

vec2 random_in_unit_disk();
vec3 rand_in_unit_sphere();
vec3 rand_unit_sphere();
vec3 rand_in_hemisphere(vec3 n);
vec3 random_cosine_direction();


//objects.glsl declarations
struct Dist {
    uint primitiveId;
    float distance;
};

float sdSphere(vec3 p, float s);
float sdBox(vec3 p, vec3 b);
float sdRoundBox(vec3 p, vec3 b, float r);
float sdPlane(vec3 p, vec3 n, float h);
float sdInfinteCylinder(vec3 p, vec3 c);
float sdCappedCylinder(vec3 p, float h, float r);
float sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r);
float sdRoundedCylinder(vec3 p, float ra, float rb, float h);
float sdSolidAngle(vec3 p, vec2 c, float ra);
float sdEllipsoid(vec3 p, vec3 r);

vec3 iElongate(vec3 pos, vec3 h);
float oElongate(float dist, vec3 pos, vec3 h);
float oBevel(float dist, float bevel);
float oOnion(float dist, float thickness);
float oMorph(float d1, float d2, float t);
float oExtrusion(float dist, vec3 pos, float h);
vec2 iScrew(vec3 pos, float o);

float bU(float d1, float d2);
Dist bU(Dist d1, Dist d2);
float bS(float d1, float d2);
Dist bS(Dist d1, Dist d2);
float bI(float d1, float d2);
Dist bI(Dist d1, Dist d2);
float bD(float d1, float d2);
Dist bD(Dist d1, Dist d2);
float sbU(float d1, float d2, float k);
Dist sbU(Dist d1, Dist d2, float k);
float sbS(float d1, float d2, float k);
Dist sbS(Dist d1, Dist d2, float k);
float sbI(float d1, float d2, float k);
Dist sbI(Dist d1, Dist d2, float k);
float sbD(float d1, float d2, float k);
Dist sbD(Dist d1, Dist d2, float k);

vec3 iTrans(vec3 pos, mat4 transform);
vec3 iScale(vec3 pos, vec3 s);
float oScale(float dist, vec3 s);
vec3 iSymX(vec3 p);
vec3 iSymY(vec3 p);
vec3 iSymZ(vec3 p);
vec3 iSymXZ(vec3 p);
float oDisp(float dist, float disp);

float deManySpheres(vec3 pos);
float deMandelbulb(vec3 pos, int Iterations, float Bailout);
float deJulia(vec3 p, int Iterations, float Bailout);
float sdRing(vec3 pos, float outer, float inner, vec3 rotation, float thickness);
float sdWarpTunnel(vec3 pos);
float test(vec3 pos);
float deKaliRemix(vec3 p, int Iterations);


//util.glsl declarations
float atan2(float y, float x);
float cdot(vec3 a, vec3 b);

vec4 ulp(vec4 value);
vec3 ulp(vec3 value);
vec2 ulp(vec2 value);
float ulp(float value);


layout(local_size_x = 32, local_size_y = 32) in;
layout(binding = 0, rgba32f) uniform image2D hdrOut;
layout(binding = 1) uniform sampler2D earth_albedo_plus_height;
layout(binding = 2) uniform sampler2D moon_albedo_plus_height;
layout(binding = 3) uniform sampler2D gasgiant_albedo;

uniform uvec2 tileOffset;
uniform uint currentSample;
uniform uint samplesPerPass;

uniform float time;
uniform mat4 viewMat;

const float FAR_PLANE = 149597870700.+696342000.*10000;

const float steps = 2000;

const bool preview = false;
const int max_bounce = 16;  // maximal number of Light bounces

const float focal_length = 50;  // focal length in mm
//const vec3 ro = vec3(0.,0.,1.); // render origin
const vec3 camera_origin = vec3(0.,0.,1.); // render origin

const float pi = 3.14159265359;

const float light_phi = pi/2;
const float light_theta = 2*pi/5;

uvec2 pixelCoord = tileOffset * gl_WorkGroupSize.xy * gl_NumWorkGroups.xy + gl_GlobalInvocationID.xy;

struct mat {
    uint type; // 0 lambertian; 1 metal; 2 pure Emmiter; 3 Volumetric
    vec3 albedo;
    float fuzz;
    float IOR;
    float alpha;
    vec3 transmission_col;
    vec3 emmission;
//preview:
    float roughness;
    float refractionIndex;
    vec3 diff_col;
    vec3 spec_col;
};

struct Entity {
    uint objectId;
    vec3 position;
    mat3 rotation;
    float scale;
};

layout(std430, column_major, binding = 0) buffer EntitiesBlock {
    Entity[] entities;
};

uint lights[] = uint[](0);


//Sphere UV project:
vec2 cartesian_to_polar(vec3 p) {
    return vec2(atan2(p.y, p.x) / (2 * pi), acos(p.z) / pi);
}

vec2 texcoord_sphereProj(vec3 p) {
    return cartesian_to_polar(normalize(p));
}

vec3 toEntitySpace(uint entityIndex, vec3 pos) {
    return (inverse(entities[entityIndex].rotation) * (pos - entities[entityIndex].position)) / entities[entityIndex].scale;
}

// TODO: could use better names, but I don't know what they represent
// TODO: really stupid way of doing this, but its the best we have
const uint P_ENTERPRISE_0 = __LINE__;
const uint P_ENTERPRISE_1 = __LINE__;
const uint P_ENTERPRISE_2 = __LINE__;
const uint P_ENTERPRISE_3 = __LINE__;
const uint P_ENTERPRISE_4 = __LINE__;
const uint P_ENTERPRISE_5 = __LINE__;
const uint P_ENTERPRISE_6 = __LINE__;
const uint P_ENTERPRISE_7 = __LINE__;

Dist sdEnterprise(vec3 pos) {
    Dist dist0 = Dist(P_ENTERPRISE_0, oBevel(sdCappedCylinder(pos, 1, 0.04), 0.02));
    Dist dist1 = Dist(P_ENTERPRISE_1, sdEllipsoid(pos, vec3(0.7, 0.2, 0.7)));
    Dist dist2 = Dist(P_ENTERPRISE_2, sdCappedCylinder(iTrans(pos, mat4(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)) + vec3( -0.8, -1.1, 0), 0.2, 0.8));
    Dist dist3 = Dist(P_ENTERPRISE_3, sdCappedCylinder(iTrans(pos, mat4(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)) + vec3(0, -2, -0.8), 0.1, 0.8));
    Dist dist4 = Dist(P_ENTERPRISE_4, sdCappedCylinder(iTrans(pos, mat4(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)) + vec3(0, -2, 0.8), 0.1, 0.8));
    Dist dist5 = Dist(P_ENTERPRISE_5, sdBox(iTrans(pos, mat4(1, 0, 0, 0, 0, cos(pi / 4), -sin(pi / 4), 0, 0, sin(pi / 4), cos(pi / 4), 0, 0, 0, 0, 1)) + vec3(-1.6, 0, 0.6), vec3(0.1, 0.6, 0.05)));
    Dist dist6 = Dist(P_ENTERPRISE_6, sdBox(iTrans(pos, mat4(1, 0, 0, 0, 0, cos(-pi / 4), -sin(-pi / 4), 0, 0, sin(-pi / 4), cos(-pi / 4), 0, 0, 0, 0, 1)) + vec3(-1.6, 0, -0.6), vec3(0.1, 0.6, 0.05)));
    Dist dist7 = Dist(P_ENTERPRISE_7, sdBox(iTrans(pos, mat4(cos(-pi / 5), - sin(-pi / 5), 0, 0, sin(-pi / 5), cos(-pi / 5), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)) + vec3(-0.2, 0.6, 0), vec3(0.2, 0.5, 0.05)));

    return sbU(sbU(sbU(sbU(sbU(sbU(sbU(dist0, dist1, 0.1), dist2, 0.01), dist3, 0.01), dist4, 0.01), dist5, 0.01), dist6, 0.01), dist7, 0.01);
}

float sdPlanet(vec3 pos, sampler2D planetTexture, float heightMapScale) {
    float height = texture(planetTexture, texcoord_sphereProj(pos)).w;
    height = height * 2 - 1;
    return oDisp(sdSphere(pos, 1), height * heightMapScale);
}

const uint O_SUN = 0;
const uint O_EARTH = 1;
const uint O_MOON = 2;
const uint O_GASGIANT = 3;
const uint O_ENTERPRISE = 4;

Dist objectDistance(uint objectId, vec3 pos) {
    switch (objectId) {
        case O_ENTERPRISE: return sdEnterprise(pos);
        case O_EARTH: return Dist(0, sdPlanet(pos, earth_albedo_plus_height, 0.0025));
        case O_MOON: return Dist(0, sdPlanet(pos, moon_albedo_plus_height, 0.01));
        case O_GASGIANT: return Dist(0, sdPlanet(pos, gasgiant_albedo, 0));
        case O_SUN: return Dist(0, sdSphere(pos, 1));
    }

    return Dist(0, 1.0 / 0.0);
}


mat transmission_lamb(vec3 lam_col, float alpha, vec3 transm_col) { return mat(100,lam_col,0,1.45,alpha,transm_col,vec3(0),.3,.3,lam_col,vec3(1)); }
mat lambertian(vec3 col) { return mat(0, col, 0, 1.45, 1, vec3(1), vec3(0), 0.3, 0.3, col, vec3(1)); }
mat metal(vec3 col, float fuzz) { return mat(1, col, fuzz, 1.45, 1, vec3(1), vec3(0), 0.1, fuzz, col, col); }
mat transmission_emm(vec3 emm_col, float alpha, vec3 transm_col) { return mat(102,vec3(0),0,1.45,alpha,transm_col,emm_col,.3,.3,emm_col,vec3(1)); }
mat emitter(vec3 col) { return mat(2, vec3(0), 0, 1.45, 1, vec3(1), col, 0, 0, col, vec3(0)); }
mat phong(vec3 col, float fuzz) { return mat(4, col, fuzz, 1.45, 1, vec3(1),vec3(0),0.3,fuzz,col,vec3(1)); }
mat cook_torrance(vec3 col, float roughness) { return mat(5, col, roughness, 1.45, 1, vec3(1),vec3(0),0.3,roughness,col,vec3(1)); }

mat planetMaterial(vec3 pos, vec3 normal, sampler2D planetTexture) {
    vec2 texelCoord = texcoord_sphereProj(pos);
    vec3 col = texture(planetTexture, texelCoord).xyz;
    return lambertian(col);
}

mat objectMaterial(uint objectId, uint primitiveId, vec3 pos, vec3 normal) {
    switch (objectId) {
        case O_ENTERPRISE: return lambertian(vec3(.8));
        case O_EARTH: return planetMaterial(pos, normal, earth_albedo_plus_height);
        case O_MOON: return planetMaterial(pos, normal, moon_albedo_plus_height);
        case O_GASGIANT: return planetMaterial(pos, normal, gasgiant_albedo);
        case O_SUN: return emitter(vec3(100000));
    }

    return emitter((sin(pos * pi) + 1) * 0.5);
}

struct hit {
    int entityIndex;
    Dist dist;
};

hit map(vec3 pos) {
    hit h = hit(-1, Dist(0, 1.0 / 0.0));
    for (int i = 0; i < entities.length(); i++) {
        Dist dist = objectDistance(entities[i].objectId, toEntitySpace(i, pos));
        dist.distance *= entities[i].scale; // correct for scale

        if (dist.distance < h.dist.distance){
            h.dist = dist;
            h.entityIndex = i;
        }
    }
    return h;
}

hit ray(vec3 ro, vec3 rd) {
    hit h = hit(-1, Dist(0, 0));
    for (uint step = 0; step < steps; step++) {
        vec3 rayEnd = ro + h.dist.distance * rd;

        hit d = map(rayEnd);
        h.dist.distance += d.dist.distance;

        if (d.dist.distance < length(ulp(rayEnd)) * 1000) {
            h.entityIndex = d.entityIndex;
            h.dist.primitiveId = d.dist.primitiveId;
            break;
        }
        if (h.dist.distance > FAR_PLANE) {
            break;
        }
    }
    return h;
}

vec3 tetraNorm(vec3 pos) {
    #if NO_UNROLL
        int ZERO = min(int(currentSample), 0); // non-constant zero
    #else
        const int ZERO = 0;
    #endif

    float h = length(ulp(pos)) * 1000;
    vec3 n = vec3(0.0);
    for (int i = ZERO; i < 4; i++) {
        vec3 dir = vec3(
            ((i + 3) >> 1) & 1,
            (i >> 1) & 1,
            i & 1
        );
        vec3 e = 0.5773 * (2 * dir - 1);
        n += e * map(pos + e * h).dist.distance;
    }
    return normalize(n);
}
vec3 calcNormal(vec3 p) {
    return tetraNorm(p);
}

float fresnel_dielectric_cos(float cosi, float eta){
    /* compute fresnel reflectance without explicitly computing
     * the refracted direction */
    float c = abs(cosi);
    float g = eta * eta - 1.0 + c * c;
    float result;

    if (g > 0.0) {
        g = sqrt(g);
        float A = (g - c) / (g + c);
        float B = (c * (g + c) - 1.0) / (c * (g - c) + 1.0);
        result = 0.5 * A * A * (1.0 + B * B);
    }
    else {
        result = 1.0; /* TIR (no refracted component) */
    }

    return result;
}

float fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta){
    /* compute fresnel reflectance without explicitly computing
     * the refracted direction */
    return fresnel_dielectric_cos(dot(Incoming, Normal), eta);
}

float node_fresnel(float ior, vec3 nor, vec3 V){
    nor = normalize(nor);
//    vec3 V = normalize(p-origin);
    //    vec3 V = cameraVec(g_data.P);

    float eta = max(ior, 0.00001);
    return fresnel_dielectric(V, nor, eta);
}

float beckmannDistribution(float dotNH, float roughness) {
    float sigma2 = roughness * roughness;
    float alpha = acos(dotNH);

    // TASK: Compute d-term
    return (exp(-((tan(alpha) / sigma2) * (tan(alpha) / sigma2))) / (pi * sigma2 * pow(cos(alpha), 4)));
}
float schlickApprox(float dotVH, float n1, float n2) {
    float r0 = (n1 - n2) / (n1 + n2);
    float r0squared = r0 * r0;

    // TASK: Compute f-term
    return r0squared + (1 - r0squared) * pow(1 - dotVH, 5);
}
float geometricAttenuation(float dotNH, float dotVN, float dotVH, float dotNL) {
    // TASK: Compute g-term
    return min(1, min((2 * dotNH * dotVN) / (dotVH), (2 * dotNH * dotNL) / dotVH));
}
float cooktorranceTerm(vec3 n, vec3 l, float roughness, float refractionIndex) {
    vec3 v = inverse(mat3(viewMat)) * vec3(0.0, 0.0, 1.0); // in eye space direction towards viewer simply is the Z axis
    vec3 h = normalize(l + v); // half-vector between V and L

    // precompute to avoid redundant computation
    float dotVN = cdot(v, n);
    float dotNL = cdot(n, l);
    float dotNH = cdot(n, h);
    float dotVH = cdot(v, h);

    float D = beckmannDistribution(dotNH, roughness);
//    float F = node_fresnel(refractionIndex, n, v);
    float F = schlickApprox(dotVH, 1.0, refractionIndex);
    float G = geometricAttenuation(dotNH, dotVN, dotVH, dotNL);

    return max(D * F * G / (4.0 * dotVN * dotNL), 0.0);
}
vec3 projected(vec3 vec, vec3 normal) {
    return normalize(vec - dot(vec, normal) * normal);
}
float orennayarTerm(float lambert, vec3 n, vec3 l, float roughness) {
    vec3 v = vec3(0.0, 0.0, 1.0);
    float sigma2 = roughness * roughness;

    float a = 1 - 0.5 * (sigma2 / (sigma2 + 0.57));
    float b = 0.45 * (sigma2 / (sigma2 + 0.09));
    float alpha = max(acos(dot(l, n)), acos(dot(v, n)));
    float beta = min(acos(dot(l, n)), acos(dot(v, n)));
    return lambert * (a + (b * cdot(projected(l, n), projected(v, n)) * sin(alpha) * tan(beta)));
}

vec3 sky(vec3 direction) {
//    float t = 0.75*(direction.x + 1.0);
//    return vec3(1.-t) + t*vec3(0.5, 0.7, 1.0);
//    return vec3(1.-t) + t*vec3(0.);
//    return vec3(col_ramp(gradient(direction-vec3(.8,0,0)), 0, 0.086, 0, 1)*10);
    //    return iTrans(direction, viewMat);
    //    return vec3(1);
    return vec3(0);
}

struct path {
    bool stop;
    vec3 attenuation;
    vec3 direction;
    vec3 emmission;
    bool specular;  // no importance sampling
//    bool inverted[num_obj];
};

vec3 reflect(vec3 v, vec3 n) {
    return v - 2*dot(v,n)*n;
}

vec3 sphere_to_cart(vec2 p){
    return vec3(cos(p.x)*sin(p.y), sin(p.x)*sin(p.y), cos(p.y));
}


struct ONB {
    vec3 u;
    vec3 v;
    vec3 w;
};
ONB built_onb(vec3 n){
    n = normalize(n);
    vec3 a = abs(n.x)>.9?vec3(0,1,0):vec3(1,0,0);
    vec3 v = normalize(cross(n, a));
    return ONB(normalize(cross(n, v)), v, n);
}
vec3 localize_to_onb(vec3 a, ONB onb){
    return a.x*onb.u+a.y*onb.v+a.z*onb.w;
}

//bool[num_obj] create_false_array(){
//    bool res[num_obj];
//    for (int i = 0; i < num_obj; ++i) res[i] = false;
//    return res;
//}

//path scatter(mat material, uint index, vec3 p, vec3 origin, vec3 normal, vec3 dir_in){
//    //how transmission works is my own idea, might not be optimal
//    //TODO: correct translucent surfaces
//    if (100 <= material.type){ //transmission
////        if (material.alpha == 0){
////            if (world[index].obj_index < 100) world[index].obj_index += 100;
////            else world[index].obj_index -= 100;
////            return path(false,vec3(1),dir_in,vec3(0));
////        }
////        if (material.alpha != 1) {
//////            world[index].obj_index = (world[index].obj_index+100)%200;
////            if (world[index].obj_index < 100) world[index].obj_index += 100;
////            else world[index].obj_index -= 100;
////            return path(false,material.alpha * material.transmission_col+material.alpha*vec3(1),dir_in,vec3(0));
////        }
//        if (rand() > material.alpha) {
////            world[index].obj_index = (world[index].obj_index+100)%200;
////            world[index].obj_index = 201;
//            if (world[index].obj_index == 1) world[index].obj_index = 101;
////            else if (world[index].obj_index == 101) world[index].obj_index = 1;
//            else world[index].obj_index = 110;
////            world[index].obj_index = 101;
////            return path(false,material.transmission_col,dir_in,vec3(0));
//            return path(false,vec3(1),dir_in,vec3(0));
//        }
//        return path(true, vec3(1), vec3(0),  normal);
////        material.type -= 100;
////        material.type = 2;
//    }
//    if (material.type == 0) {  //lambertian
//        vec3 new_direction =  normalize(normalize(normal) + rand_unit_sphere());
//        return path(false, material.albedo, new_direction, vec3(0));
//    }
//    if (material.type == 1){ //metal
//        vec3 new_direction = normalize(normalize(reflect(dir_in, normal)) + material.fuzz*rand_in_unit_sphere());
//        return path(dot(new_direction, normal) <= 0, material.albedo, new_direction, vec3(0));
//    }
//    if (material.type == 2){ //emmission
//        return path(true, vec3(1), vec3(0), material.emmission);
//    }
//    if (material.type == 3){ //gloss
//        vec3 new_direction = normalize(normalize(reflect(dir_in, normal)) + material.fuzz*rand_in_unit_sphere());
//        return path(dot(new_direction, normal) <= 0, vec3(1), new_direction, vec3(0));
//    }
//    if (material.type == 4){ //phong
//        float fresnel = node_fresnel(material.IOR, normal, p, origin);
////        return path(true, vec3(1), vec3(0), vec3(fresnel));
//        vec3 new_direction_lambert =  normalize(normalize(normal) + rand_unit_sphere());
//        vec3 new_direction_gloss = normalize(normalize(reflect(dir_in, normal)) + material.fuzz*rand_in_unit_sphere());
//        vec3 new_direction = mix(new_direction_lambert, new_direction_gloss, fresnel);
//        return path(dot(new_direction, normal) <= 0, mix(material.albedo, vec3(1), fresnel), new_direction, vec3(0));
//    }
//    return path(true, vec3(0),vec3(0),vec3(0));
//}

float rough_to_expo(float rough){
    return 4500.*pow(1000000., -rough)-0.004;  // experimenteller schätzungswert
}

path scatter(mat material, uint objectId, vec3 p, vec3 origin, vec3 normal, vec3 dir_in, ONB onb, out float pdf){
//    if (100 <= material.type){ //transmission
////        if (material.alpha == 0){
////            if (world[index].obj_index < 100) world[index].obj_index += 100;
////            else world[index].obj_index -= 100;
////            return path(false,vec3(1),dir_in,vec3(0));
////        }
////        if (material.alpha != 1) {
//////            world[index].obj_index = (world[index].obj_index+100)%200;
////            if (world[index].obj_index < 100) world[index].obj_index += 100;
////            else world[index].obj_index -= 100;
////            return path(false,material.alpha * material.transmission_col+material.alpha*vec3(1),dir_in,vec3(0), false);
////        }
//        if (rand() > material.alpha) {
////            world[index].obj_index = (world[index].obj_index+100)%200;
////            world[index].obj_index = 201;
//            if (world[index].obj_index == 1) world[index].obj_index = 101;
////            else if (world[index].obj_index == 101) world[index].obj_index = 1;
//            else world[index].obj_index = 110;
////            world[index].obj_index = 101;
////            return path(false,material.transmission_col,dir_in,vec3(0));
//            return path(false,vec3(1),dir_in,vec3(0), false);
//        }
//        pdf = 1;
//        return path(true, vec3(1), vec3(0),  vec3(1), false);
////        material.type -= 100;
////        material.type = 2;
//    }
    if (material.type == 0) {  //lambertian
        vec3 new_direction = normalize(localize_to_onb(random_cosine_direction(), onb));

//        vec3 new_direction =  normalize(normalize(normal) + rand_unit_sphere());
//        if ((new_direction.x < 1e-8) && (new_direction.y < 1e-8) && (new_direction.z < 1e-8))
//            new_direction = normal;
        pdf = dot(normal, new_direction)/pi;
        return path(false, material.albedo, new_direction, vec3(0), false/*, create_false_array()*/);
    }
//    if (material.type == 1) { //metal
//        // funktioniert nur gut für kleine fuzz, da kein importance sampling
//        vec3 new_direction = normalize(normalize(reflect(dir_in, normal)) + material.fuzz*rand_in_unit_sphere());
//        pdf = 1;
//        return path(dot(new_direction, normal) <= 0, material.albedo, new_direction, vec3(0), true);
//    }
    if (material.type == 2){ //emmission
        return path(true, vec3(1), vec3(0), material.emmission, false/*, create_false_array()*/);
    }
//    if (material.type == 4){ //phong
////        float fresnel = node_fresnel(material.IOR, normal, p, origin);
//        float ks = .5;
//        float kd = 1-ks;
//        float n = rough_to_expo(material.fuzz);
////        float alpha = pi;
////        float brdf = kd/pi*ks*(n+2)/2*pi*pow(cos(alpha), n);
//        if (rand() < kd){  // diffuse
////            return path(true, vec3(1), vec3(0), vec3(1,0,0), false);
//            vec3 new_direction = normalize(localize_to_onb(random_cosine_direction(), onb));
//            pdf = dot(normal, new_direction)/pi;
//            return path(false, material.albedo, new_direction, vec3(0), false);
//        }
//        else{  // specular
//            ONB refl_onb = built_onb(reflect(dir_in, normal));
//            vec3 new_direction = sphere_to_cart(vec2(acos(pow(rand(), 1/float(n+1))), 2*pi*rand()));
//            new_direction = normalize(localize_to_onb(new_direction, refl_onb));
////            pdf = (n+1)/(2*pi)*pow(dot(reflect(dir_in, normal), new_direction), n);
//            pdf = (n+1)/(2*pi)*pow(dot(reflect(new_direction, normal), dir_in), n);
//            return path(false, vec3(1), new_direction, vec3(0), true);
//        }
//    }
    if (material.type == 5){ //cook_torrance
        float roughness = .1;
        float IOR = 1.45;
//        float F = schlickApprox(cdot(vec3(), normalize(dir_in)), 1.0, IOR);
        float F = .5;
        if (rand() < F){  // diffuse
            vec3 new_direction = normalize(localize_to_onb(random_cosine_direction(), onb));
            pdf = dot(normal, new_direction)/pi;
            return path(false, material.albedo, new_direction, vec3(0), false/*, create_false_array()*/);
        }
        else { // specular
            float z1 = rand(), z2 = rand();
            float theta_m = atan(sqrt(-roughness*roughness*log(1-z1)));
            float phi_m = 2*pi*z2;
            vec3 m = sphere_to_cart(vec2(theta_m, phi_m));
            vec3 o = 2*abs(dot(dir_in, m))*m-dir_in;
            vec3 new_dir = normalize(localize_to_onb(o, onb));
            float pdf = beckmannDistribution(cdot(normal, normalize(new_dir + dir_in)), roughness)*abs(dot(m, normal))/(4*abs(dot(o, m)));
            return path(false, vec3(1), new_dir, vec3(0), true/*, create_false_array()*/);
        }

//            ONB refl_onb = built_onb(reflect(dir_in, normal));
//            vec3 new_direction = sphere_to_cart(vec2(acos(pow(rand(), 1/float(n+1))), 2*pi*rand()));
//            new_direction = normalize(localize_to_onb(random_cosine_direction(), refl_onb));
//            //            pdf = (n+1)/(2*pi)*pow(dot(reflect(dir_in, normal), new_direction), n);
//            pdf = (n+1)/(2*pi)*pow(dot(reflect(new_direction, normal), dir_in), n);
//        }
    }
    return path(true, vec3(0),vec3(0),vec3(0), false/*, create_false_array()*/);
}

path scatter_light(vec3 p, vec3 normal, ONB onb, out float pdf){
    float random_light = rand();
    uint light_index = lights[uint(random_light * lights.length())];
    vec3 position = entities[light_index].position;
    float radius = entities[light_index].scale;

    vec3 on_light = position + radius * rand_in_unit_sphere();
    vec3 new_direction = normalize(on_light - p);

    float cos_theta_max = sqrt(abs(1 - radius*radius/(length(position-p)*length(position-p))));
    float solid_angle = 2*pi*(1-cos_theta_max);
    if (radius/length(position-p) > 1) pdf = 0; else pdf = 1/solid_angle;
    pdf = 1/solid_angle;

    return path(dot(new_direction, normal) < 0, vec3(1), new_direction, vec3(0), false/*, create_false_array()*/);
}

float scattering_pdf(mat material, uint objectId, vec3 p, vec3 origin, vec3 normal, vec3 scattered, vec3 dir_in, bool specular){
//    if (100 <= material.type) return 1;
    float cosine = dot(normal, normalize(scattered));
    if (material.type == 0) {  //lambertian
        return cosine < 0 ? 0 : cosine/pi;
    }
    if (material.type == 2) return 1;
//    if (material.type == 4){ //phong
//        // experimentelle Vergleichswerte mit Blender.
//        // Abweichung existiert da Blender Microfacettenshader nutzt und kein cosine-lobe
//        //rough = 0 ca. n = 5000
//        //rough = 1 => n = 0
//        //rough = .5 ca n= 5
//        //rough = 0.1673320053 ca n = 300 bis n = 200
//
////        float fresnel = node_fresnel(material.IOR, normal, p, origin);
//        float ks = .5;
//        float kd = 1-ks;
//        float n = rough_to_expo(material.fuzz);
////        float cos_alpha = dot(reflect(dir_in, normal), scattered);
////        float brdf = kd/pi+ks*(n+2)/2*pi*pow(cos_alpha, n);
////        vec3 h = normalize(dir_in+scattered);
////        float brdf;
////        if (specular) brdf = (n+1)/(2*pi)*pow(dot(reflect(scattered, normal), dir_in), n);
////        else brdf = 1/pi;
//        float brdf = kd/pi+ks*(n+2)/(2*pi)*pow(dot(reflect(scattered, normal), dir_in), n);
//        return brdf*cosine;
//    }
    if (material.type == 5){ //cook-torrance
        float roughness = .1;
        float IOR = 1.45;
        vec3 h = normalize(dir_in+scattered);
        float F = schlickApprox(cdot(h, normalize(dir_in)), 1.0, IOR);
        return (cosine < 0 ? 0 : cosine/pi)*(1-F)+
            F*beckmannDistribution(cdot(normal, h), roughness)*
            geometricAttenuation(cdot(normal, h), cdot(dir_in, normal), cdot(dir_in, h), cdot(normal, scattered))/
            (4*abs(dot(dir_in, normal))*abs(dot(scattered, normal)));
    }
    return 0;
}

vec3 polar_to_cartisan(vec2 p){
    p = vec2(p.x*2*pi, p.y*pi);
    return vec3(cos(p.x)*sin(p.y), sin(p.x)*sin(p.y), cos(p.y));
}

vec3 pathtracing(vec3 origin, vec3 direction) {
    path trace = path(false, vec3(1), direction, vec3(0), false/*, create_false_array()*/);
    for (int i = 0; i < max_bounce; i++) {
        hit r = ray(origin, trace.direction);
        if (r.entityIndex >= 0) {
            Entity entity = entities[r.entityIndex];

            vec3 p = origin + r.dist.distance * trace.direction;
            vec3 normal = calcNormal(p);
            mat material = objectMaterial(entity.objectId, r.dist.primitiveId, toEntitySpace(r.entityIndex, p), normal);

            ONB onb = built_onb(normal);
            float pdf_material = 0;
            path new_trace = scatter(material, entity.objectId, p, origin, normal, trace.direction, onb, pdf_material);
//            if (new_trace.specular){
//                trace = path(new_trace.stop,
//                trace.attenuation*new_trace.attenuation,
//                new_trace.direction, trace.emmission+new_trace.emmission*trace.attenuation, false);
//            }
//            else {
                //sampling all directions
                //            vec3 a_new = new_trace.attenuation*scattering_pdf(material, r.index, p, origin, normal, new_trace.direction)/pdf;
                //            trace = path(trace.stop||new_trace.stop, trace.attenuation*a_new, new_trace.direction, trace.emmission+new_trace.emmission*trace.attenuation);
                //            origin = p+2*obj.eps*normalize(trace.direction+normal);

                //sampling only light
            float pdf_light = 0;
            path light_trace = scatter_light(p, normal, onb, pdf_light);

            //            int random_pdf = int(floor(rand()*2.));
            vec3 scattered = rand() < .5 ? new_trace.direction : light_trace.direction;
//            vec3 scattered = new_trace.direction;
            //            vec3 scattered = light_trace.direction;
            //            vec3 new_direction = random_pdf==0?new_trace.direction:light_trace.direction;
            //            pdf_light = 1/pdf_light*10;
            //            pdf_light = pdf_light;
            //            pdf_light = 10000000;
            if (isnan(pdf_light)) return vec3(1, 0, 0);
            //            pdf_light = 1;
            //            return vec3(1/pdf_light);
            //            vec3 new_direction = new_trace.direction;
            float pdf_val = .5 * pdf_material + .5 * pdf_light;
//            float pdf_val = pdf_material;
//                        float pdf = random_pdf==0?pdf_material:pdf_light;
            //            float pdf_val = pdf_light;

            //            trace = path(new_trace.stop||light_trace.stop,
            //                trace.attenuation*new_trace.attenuation*scattering_pdf(material, r.index, p, origin, normal, light_trace.direction)/pdf_light,
            //                light_trace.direction, trace.emmission+new_trace.emmission*trace.attenuation);
            trace = path(
                new_trace.stop, //||light_trace.stop,
                trace.attenuation * new_trace.attenuation * scattering_pdf(material, entity.objectId, p, origin, normal, scattered, trace.direction, new_trace.specular) / pdf_val,
                scattered,
                trace.emmission + new_trace.emmission * trace.attenuation,
                false/*,
                trace.inverted*/
            );
//            for (int j = 0; j < num_obj; ++j) trace.inverted[j] = (trace.inverted[j] == new_trace.inverted[j]);
//
////            }

            float eps = length(ulp(p)) * 1000;
            origin = p + 2 * eps * normalize(trace.direction + normal);
        }
        else {
            //            vec3 col = refl*sky(iTrans(trace.direction, inverse(viewMat)));
//            vec3 col = trace.emmission + trace.attenuation*sky(inverse(mat3(viewMat))*trace.direction);
            vec3 col = trace.emmission + trace.attenuation * sky(trace.direction);
            return col;
            //            emit_accum += attenuation_accum*sky(iTrans(trace.direction, inverse(viewMat)));
            //            return emit_accum;
        }
        if (trace.stop) return trace.emmission;
    }
    return vec3(0);
}

vec3 getRayDir(vec2 p, float aspect){
    float sensor_width = 35; // sensor width is identic to Blender Camera
    float FOV = 2 * atan(sensor_width/(2*focal_length));  // in rad
    float renderWidth = 2;
    float z0 = renderWidth / (2 * tan(FOV / 2));
    p.x *= aspect;
    return normalize(vec3(p.xy,-z0));
}

void main(){
    uvec2 texelCoord = ivec2(pixelCoord); // TODO: confusing naming
    ivec2 resolution = imageSize(hdrOut);

    if (texelCoord.x >= resolution.x || texelCoord.y >= resolution.y) return;

    vec3 ro = inverse(mat3(viewMat)) * (camera_origin - viewMat[3].xyz);
    vec2 p = (vec2(texelCoord) / resolution) * 2 - 1;
    float aspect = float(resolution.x) / float(resolution.y);

    vec4 col = vec4(.1,.1,.1, 1);
    if (preview) {
        vec3 light_dir = vec3(cos(light_phi)*sin(light_theta),cos(light_theta),sin(light_phi)*sin(light_theta));
        //    vec3 interp_light_dir = normalize((viewMat * vec4(light_dir, 0.0)).xyz);
        vec3 interp_light_dir = normalize(light_dir);

        vec3 rd = inverse(mat3(viewMat)) * getRayDir(p, aspect);
        hit r = ray(ro, rd);

        if (r.entityIndex >= 0) {
            Entity entity = entities[r.entityIndex];

            vec3 pos = ro + r.dist.distance * rd;
            vec3 nor = calcNormal(pos);
            mat material = objectMaterial(entity.objectId, r.dist.primitiveId, pos, nor);

            float diffuseTerm = cdot(nor, interp_light_dir);
            diffuseTerm = orennayarTerm(diffuseTerm, nor, interp_light_dir, material.roughness);
            diffuseTerm = max(diffuseTerm, 0.1);

            float specularTerm = cooktorranceTerm(nor, interp_light_dir, material.roughness, material.refractionIndex);
            col = vec4(clamp(material.diff_col * diffuseTerm + material.spec_col * specularTerm, 0.0, 1.0), 1);

//            vec3 diff_col = vec3(0);
//            vec3 map = mapping(pos, obj);
            //            diff_col = vec3(fade(.1));
            //            diff_col = vec3(perlin_noise_p(map.x,map.y,map.z));
//            float val;
//            vec4 coll;
//            node_noise_texture_3d(map, 10., 2., 0.5, 0., val, coll);
//            diff_col = coll.xyz;

//            col = clamp(vec4(diff_col,1) * diffuseTerm + vec4(obj.material.spec_col,1) * specularTerm, 0.0, 1.0);

//            //        hit tmp = ray(pos+nor*eps(t)*2, interp_light_dir);
//            hit tmp = ray(pos+nor*obj.eps*2, interp_light_dir);
//            float TMP = (tmp.hit) ? tmp.dist : 0;
//            float sun_sh = step(TMP, 0.0);
//            vec4 shadow = vec4(1, 1, 1, 1)*clamp(10*pow(0.18*sun_sh, 0.4545), 0.4, 1.);
//            //            col = col*shadow;
//
//            //            col = world[r.index].diff_col;
//            //            col = vec4(inverse(mat3(viewMat))*nor,1);
//            vec3 map = texcoord_nor(pos, obj);
//            col = vec4(map,1);
        }
    }
    else {
        vec3 pathTraceCol = vec3(0);
        for (int i = 0; i < samplesPerPass; i++) {
            vec3 rd = inverse(mat3(viewMat)) * getRayDir(p + (rand2() / resolution) * 2, aspect);
//            vec3 rd = (viewMat*vec4(getRayDir(p+vec2(2.*rand()-1.,2.*rand()-1.)/resolution.y,aspect),0)).xyz;
            pathTraceCol += pathtracing(ro, rd);
        }
        vec4 pcol = vec4(pathTraceCol,1);
        col = imageLoad(hdrOut, ivec2(texelCoord));
        col.xyz = (float(currentSample) / float(currentSample + samplesPerPass)) * col.xyz + pcol.xyz / float(currentSample + samplesPerPass);
    }

    imageStore(hdrOut, ivec2(texelCoord), col);
}